# Описание протокола

Протокол взаимодействия реализован с использованием сокетов и предназначен для обмена данными между клиентом и сервером. Протокол поддерживает сериализацию данных в формате JSON и передачу через сеть с использованием заголовков фиксированной длины.

---

## Общая структура сообщения

Каждое сообщение состоит из двух частей:

1. **Заголовок (Header)**: фиксированная длина (4 байта), содержащая длину полезной нагрузки (payload) в байтах.
2. **Полезная нагрузка (Payload)**: сериализованные данные в формате JSON.

Формат заголовка определяется строкой `HEADER_FORMAT = "!I"`, где `!` указывает на сетевой порядок байтов (Big Endian), а `I` обозначает целое число (4 байта).

---

## Поддерживаемые команды

### 1. `gun_command`
- **Описание**: передает команду для управления пушкой.
- **Формат**:
  ```json
  {
      "type": "gun_command",
      "payload": {
          "command": "<command>"
      }
  }
  ```
- **Использование**:
  - Кодирование: `Protocol.encode_gun_command(command)`
  - Декодирование: `Protocol.decode_gun_command(data)`

### 2. `state_update`
- **Описание**: передает состояние игры, включая позиции кораблей и состояние пушки.
- **Формат**:
  ```json
  {
      "type": "state_update",
      "payload": {
          ...  // Структура состояния игры
      }
  }
  ```
- **Использование**:
  - Кодирование: `Protocol.encode_game_state(state)`
  - Декодирование: `Protocol.decode_game_state(data)`

### 3. `reset_game`
- **Описание**: команда сброса игры до начального состояния.
- **Формат**:
  ```json
  {
      "type": "reset_game",
      "payload": {}
  }
  ```
- **Использование**:
  - Кодирование: `Protocol.encode_reset_command()`

### 4. `fire`
- **Описание**: команда запуска выстрела из пушки.
- **Формат**:
  ```json
  {
      "type": "fire",
      "payload": {}
  }
  ```
- **Использование**:
  - Кодирование: `Protocol.encode_bomb_command()`

---

## Особенности реализации

1. **Отправка сообщений**:
   - Сообщение сначала кодируется в JSON, затем сериализуется в бинарный формат.
   - Заголовок содержит длину сообщения для обеспечения корректной обработки.

2. **Получение сообщений**:
   - Принимается фиксированное количество байт для заголовка.
   - На основе длины, указанной в заголовке, принимается оставшаяся часть сообщения.

3. **Транспортный протокол**:
   - Протокол работает на основе **TCP**. Использование методов `sendall` и `recv` подразумевает надежное соединение, гарантирующее порядок доставки и целостность данных.

---

## Пример использования

### Отправка команды управления пушкой
```python
import socket

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(('127.0.0.1', 65432))

# Отправляем команду
encoded_data = Protocol.encode_gun_command("rotate_left")
sock.sendall(encoded_data)
```

### Получение состояния игры
```python
# Получение данных из сокета
data = sock.recv(1024)
state = Protocol.decode_game_state(data)
print("Текущее состояние игры:", state)
```

---

## Преимущества

- **Простота использования**: благодаря унифицированной структуре сообщений добавление новых команд не вызывает сложностей.
- **Масштабируемость**: легко адаптируется под дополнительные требования.
- **Защита от ошибок**: каждая команда проверяет тип и структуру сообщения, минимизируя риски некорректной обработки данных.

---

## Возможное расширение

Если потребуется использовать протокол на основе **UDP** (например, для повышения скорости передачи данных в реальном времени), нужно будет внести следующие изменения:

1. Заменить методы `sendall` и `recv` на `sendto` и `recvfrom`.
2. Реализовать повторную отправку сообщений при их потере.
3. Добавить идентификаторы сообщений для обеспечения порядка их обработки.

Если вы хотите адаптировать протокол или добавить новые команды, свяжитесь с разработчиками!

